// Copyright Â© 2020. All rights reserved.
// Author: Ilya Stroy.
// Contacts: qioalice@gmail.com, https://github.com/qioalice
// License: https://opensource.org/licenses/MIT

package ekalog

import (
	"image/color"
	"strconv"
	"strings"

	"github.com/qioalice/ekago/v2/internal/xtermcolor"
)

type (
	// colorBuilder is a helper to construct bash color escape sequence
	// (like "\033[01;03;38;05;144m") to represent a some color.
	//
	// Objects of this type are instantiated at the color verbs parsing, their
	// fields are filed by values provided at the verb and then bash sequence
	// is generated by encode().
	//
	// See https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_parameters for more info.
	colorBuilder struct {

		// if bg == 100 it means full reset to default colors is requested
		// no one next verb's part will be processed

		// [0..255] - xterm256 ANSI SGR color code
		// -1 if 'do cleanup color to terminal default' ( "\033[39m" or "\033[49m" )
		// -2 if 'not set, use those one that was used' (not included to SGR)
		bg, fg int16

		// 0 - 'not set, use those one that was used' (not included to SGR)
		// 1 - enable (included to SGR (01/03/04))
		// -1 - disable (included to SGR (22/23/24))
		bold, italic, underline int8

		// Yes, there is no support blinking text.
		// I think it's disgusting. It will never be added.
	}
)

//
func (cb *colorBuilder) init() {
	cb.bg, cb.fg = -2, -2
	cb.bold, cb.italic, cb.underline = 0, 0, 0
}

//
func (cb *colorBuilder) parseEntity(verbPart string) (parsed bool) {

	if cb.bg == 100 {
		return true
	}

	switch verbPart = strings.ToUpper(strings.TrimSpace(verbPart)); verbPart {
	// --- REMINDER! 1ST ARGUMENT IS ALWAYS UPPER CASED! ---

	case "":
		return true

	case "0":
		cb.bg = 100
		return true

	case "BOLD", "B":
		cb.bold = 1
		return true

	case "NOBOLD", "NOB":
		cb.bold = -1
		return true

	case "ITALIC", "I":
		cb.italic = 1
		return true

	case "NOITALIC", "NOI":
		cb.italic = -1
		return true

	case "UNDERLINE", "U":
		cb.underline = 1
		return true

	case "NOUNDERLINE", "NOU":
		cb.underline = -1
		return true
	}

	// okay, it's color, but which one? what format? RGB? HEX? RGBA? (lol, wtf?)
	// TODO: Add supporting of color's literals like "red", "pink", "blue", etc.

	// what's kind of color? default is fg
	var colorDestination *int16
	switch {

	case strings.HasPrefix(verbPart, "BG:"):
		colorDestination = &cb.bg
		verbPart = strings.TrimSpace(verbPart[3:])

	case strings.HasPrefix(verbPart, "FG:"): // already defaulted
		colorDestination = &cb.fg
		verbPart = strings.TrimSpace(verbPart[3:])

	default:
		colorDestination = &cb.fg
	}

	// handle special easy cases cases
	switch {
	case len(verbPart) == 0:
		// rare case, wasn't more chars after "bg" or "fg"
		return false

	case verbPart == "-1":
		// color cleanup (to default in term)
		*colorDestination = -1
		return true

	case verbPart[0] == '#':
		// easy case if it's explicit hex
		return cb.parseHexTo(verbPart[1:], colorDestination)
	}

	// maybe default ASCII seq?
	switch {
	case strings.HasPrefix(verbPart, "ASCII:"):
		return cb.parseBaseASCIITo(verbPart[6:], colorDestination)

	case strings.HasPrefix(verbPart, "ASCII(") && verbPart[len(verbPart)-1] == ')':
		return cb.parseBaseASCIITo(verbPart[6:len(verbPart)-1], colorDestination)
	}

	// okay, maybe easy rgb/rgba?
	switch {
	case strings.HasPrefix(verbPart, "RGB:"):
		return cb.parseRgbTo(verbPart[4:], colorDestination)

	case strings.HasPrefix(verbPart, "RGBA:"):
		return cb.parseRgbTo(verbPart[5:], colorDestination)

	case strings.HasPrefix(verbPart, "RGB(") && verbPart[len(verbPart)-1] == ')':
		return cb.parseRgbTo(verbPart[4:len(verbPart)-1], colorDestination)

	case strings.HasPrefix(verbPart, "RGBA(") && verbPart[len(verbPart)-1] == ')':
		return cb.parseRgbTo(verbPart[4:len(verbPart)-1], colorDestination)
	}

	// okay maybe rgb by comma?
	if commas := strings.Count(verbPart, ","); commas >= 3 && commas <= 4 {
		return cb.parseRgbTo(verbPart, colorDestination)
	}

	// believe it's just XTerm 256 colors code
	return cb.parseX256To(verbPart, colorDestination)
}

//
func (_ *colorBuilder) parseBaseASCIITo(verbPart string, destination *int16) (parsed bool) {
	// --- REMINDER! 1ST ARGUMENT IS ALWAYS UPPER CASED! ---

	asciiColor, _ := strconv.Atoi(verbPart)
	// it's not necessary to check err, cause if error is occurred, asciiColor == 0
	if (asciiColor >= 30 && asciiColor <= 37) || (asciiColor >= 40 && asciiColor <= 47) ||
		(asciiColor >= 90 && asciiColor <= 97) || (asciiColor >= 100 && asciiColor <= 107) {

		*destination = int16(asciiColor) | (1 << 14)
		return true
	}

	return false
}

//
func (_ *colorBuilder) parseX256To(verbPart string, destination *int16) (parsed bool) {

	xterm256color, err := strconv.Atoi(verbPart)
	if err != nil || xterm256color < 0 || xterm256color > 255 {
		return false
	}

	*destination = int16(xterm256color)
	return true
}

//
func (_ *colorBuilder) parseHexTo(verbPart string, destination *int16) (parsed bool) {
	// --- REMINDER! 1ST ARGUMENT IS ALWAYS UPPER CASED! ---

	switch verbPart = strings.TrimSpace(verbPart); len(verbPart) {
	case 4:
		// short case with alpha, ignore alpha, extend to 6
		verbPart = verbPart[:3]
		fallthrough
	case 3:
		// short case, extend to 6
		var hexParts [6]uint8
		hexParts[0], hexParts[1] = verbPart[0], verbPart[0]
		hexParts[2], hexParts[3] = verbPart[1], verbPart[1]
		hexParts[4], hexParts[5] = verbPart[2], verbPart[2]
		verbPart = string(hexParts[:])
	case 8:
		// with alpha, ignore it
		verbPart = verbPart[:6]
	case 6:
		// default HEX case, handle later
	default:
		return false
	}

	termColor, err := xtermcolor.FromHexStr(verbPart)
	*destination = int16(termColor)

	return err == nil
}

//
func (_ *colorBuilder) parseRgbTo(verbPart string, destination *int16) (parsed bool) {
	// --- REMINDER! 1ST ARGUMENT IS ALWAYS UPPER CASED! ---

	rgbParts := strings.Split(strings.TrimSpace(verbPart), ",")
	if l := len(rgbParts); l < 3 && l > 4 {
		return false
	}

	var (
		r, g, b          int
		err1, err2, err3 error
	)

	r, err1 = strconv.Atoi(strings.TrimSpace(rgbParts[0]))
	g, err2 = strconv.Atoi(strings.TrimSpace(rgbParts[1]))
	b, err3 = strconv.Atoi(strings.TrimSpace(rgbParts[2]))

	if err1 != nil || err2 != nil || err3 != nil ||
		r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255 {
		return false
	}

	rgb := color.RGBA{R: uint8(r), G: uint8(g), B: uint8(b), A: 255}
	*destination = int16(xtermcolor.FromColor(rgb))

	return true
}

//
func (cb *colorBuilder) encode() string {

	if cb.bg == 100 {
		return "\033[0m"
	}

	// TODO: Here is too much Golang string mem reallocations
	//  maybe use []byte instead of string with only one allocation ?

	// https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_parameters
	out := "\033["

	switch cb.bold {
	case 1:
		out += "01;" // enable bold
	case -1:
		out += "22;" // disable bold
	}

	switch cb.italic {
	case 1:
		out += "03;" // enable italic
	case -1:
		out += "23;" // disable italic
	}

	switch cb.underline {
	case 1:
		out += "04;" // enable underline
	case -1:
		out += "24;" // disable underline
	}

	switch /* FOREGROUND COLOR */ {
	case cb.fg == -2:
		// do nothing, use those one that was used
	case cb.fg == -1:
		// set foreground to term default
		out += "39;"
	case cb.fg&(1<<14) != 0:
		// first 16 ASCII sys colors
		cb.fg &^= 1 << 14
		if cb.fg >= 40 && cb.fg <= 47 || cb.fg >= 100 {
			cb.fg -= 10
		}
		out += strconv.Itoa(int(cb.fg)) + ";"
	default:
		out += "38;5;" + strconv.Itoa(int(cb.fg)) + ";"
	}

	switch /* BACKGROUND COLOR */ {
	case cb.bg == -2:
		// do nothing, use those one that was used
	case cb.bg == -1:
		// set background to term default
		out += "49;"
	case cb.bg&(1<<14) != 0:
		// first 16 ASCII sys colors
		cb.bg &^= 1 << 14
		if cb.bg < 40 || cb.bg >= 90 && cb.bg <= 97 {
			cb.bg += 10
		}
		out += strconv.Itoa(int(cb.fg)) + ";"
	default:
		out += "48;5;" + strconv.Itoa(int(cb.bg)) + ";"
	}

	if out[len(out)-1] != ';' {
		return "" // all values are default and ignored
	}

	out = out[:len(out)-1] + "m"
	return out
}
